{"version":3,"file":"react-spectrum.es.js","sources":["../src/utils/arraysEqual.ts","../src/utils/getRandomInRange.ts","../src/utils/getWords.ts","../src/usePrevious.tsx","../src/DrawLine.tsx","../src/Spectrum.tsx"],"sourcesContent":["function arraysEqual(\n  a: Array<string | number>,\n  b: Array<string | number>,\n): boolean {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  const sortedA = [...a].sort();\n  const sortedB = [...b].sort();\n  for (let i = 0; i < sortedA.length; i += 1) {\n    if (sortedA[i] !== sortedB[i]) return false;\n  }\n\n  return true;\n}\n\nexport default arraysEqual;\n","function getRandomInRange(min: number, max: number): number {\n  const mn = Math.ceil(min);\n  const mx = Math.floor(max);\n\n  return Math.floor(Math.random() * (mx - mn + 1)) + mn;\n}\n\nexport default getRandomInRange;\n","import getRandomInRange from './getRandomInRange';\n\nconst getWords = ({\n  width,\n  colors,\n  wordWidths,\n  wordDistances,\n  truncate,\n}: {\n  width: number;\n  colors: Array<string>;\n  wordWidths: Array<number>;\n  wordDistances: Array<number>;\n  truncate: boolean;\n}): Array<{ width: number; distance: number; background: string }> => {\n  const minWordWidth = Math.min(...wordWidths);\n  const maxWordsPerLine = Math.floor(width / minWordWidth);\n  const wordForLine = getRandomInRange(\n    Math.max(\n      0,\n      truncate ? 1 : maxWordsPerLine - Math.floor(maxWordsPerLine / 2),\n    ),\n    truncate ? Math.floor(maxWordsPerLine / 2) : maxWordsPerLine,\n  );\n\n  const words = [];\n  let totalWidth = 0;\n  for (let i = 0; i < wordForLine; i += 1) {\n    const wordWidth = wordWidths[getRandomInRange(0, wordWidths.length - 1)];\n    let wordDistance =\n      wordDistances[getRandomInRange(0, wordDistances.length - 1)];\n\n    const totalWidthWithoutDistance = totalWidth + wordWidth;\n    totalWidth = totalWidthWithoutDistance + wordDistance;\n\n    // If we can just fit the word without margin, push it by resetting margin\n    const fitWord = totalWidthWithoutDistance <= width && totalWidth > width;\n    const fitWordWithDistance = totalWidth <= width;\n\n    if (fitWord || fitWordWithDistance) {\n      // If we are fitting the word, assume that it's the last word\n      // so, reset it's distance\n      if (fitWord && !fitWordWithDistance) {\n        wordDistance = 0;\n      }\n\n      const background = colors[getRandomInRange(0, colors.length - 1)];\n      words.push({ width: wordWidth, distance: wordDistance, background });\n\n      // If we are fitting the word, it's the last word\n      if (fitWord && !fitWordWithDistance) {\n        break;\n      }\n    } else {\n      // If we cannot fit the word into the line\n      // clear the margin of the last word\n      const [last] = [...words].reverse();\n      if (last) {\n        last.distance = 0;\n      }\n      break;\n    }\n  }\n\n  return words;\n};\n\nexport default getWords;\n","import * as React from 'react';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction usePrevious(value: any): any {\n  const ref = React.useRef(null);\n\n  React.useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n\nexport default usePrevious;\n","import * as React from 'react';\nimport arraysEqual from './utils/arraysEqual';\nimport getWords from './utils/getWords';\nimport usePrevious from './usePrevious';\nimport { RenderWordProps } from './Spectrum';\n\ninterface DrawLineProps {\n  width: number;\n  colors: Array<string>;\n  wordWidths: Array<number>;\n  wordDistances: Array<number>;\n  truncate: boolean;\n  wordHeight: number;\n  wordRadius: number;\n  lineDistance: number;\n  renderWord: React.FC<RenderWordProps>;\n}\n\nconst DrawLine = ({\n  width,\n  colors,\n  wordWidths,\n  wordDistances,\n  wordHeight,\n  wordRadius,\n  lineDistance,\n  truncate,\n  renderWord,\n}: DrawLineProps): React.ReactElement => {\n  const previous = usePrevious({\n    width,\n    colors,\n    wordWidths,\n    wordDistances,\n    wordHeight,\n    wordRadius,\n    lineDistance,\n    truncate,\n    renderWord,\n  });\n  const [words, setWords] = React.useState(() =>\n    getWords({\n      width,\n      colors,\n      wordWidths,\n      wordDistances,\n      truncate,\n    }),\n  );\n\n  React.useEffect(() => {\n    // Handle props update on the runtime\n    // Memo isn't helping here as props contains array\n    // whose reference might change on every re-render\n    if (\n      previous &&\n      (previous.width !== width ||\n        previous.wordHeight !== wordHeight ||\n        previous.wordRadius !== wordRadius ||\n        previous.lineDistance !== lineDistance ||\n        previous.truncate !== truncate ||\n        !arraysEqual(previous.wordWidths, wordWidths) ||\n        !arraysEqual(previous.wordDistances, wordDistances) ||\n        !arraysEqual(previous.colors, colors))\n    ) {\n      const newWords = getWords({\n        width,\n        colors,\n        wordWidths,\n        wordDistances,\n        truncate,\n      });\n\n      setWords(newWords);\n    }\n  }, [\n    previous,\n    width,\n    colors,\n    wordWidths,\n    wordDistances,\n    truncate,\n    wordHeight,\n    wordRadius,\n    lineDistance,\n  ]);\n  return (\n    <>\n      {words.map(({ width: w, distance, background }, i) => {\n        const style = {\n          width: w,\n          marginRight: distance,\n          height: wordHeight,\n          background,\n          display: 'inline-block',\n          borderRadius: wordRadius,\n          marginBottom: lineDistance,\n        };\n\n        // Ensure only synchronous results are rendered\n        const node = renderWord({ key: i, style });\n        if (node instanceof Promise) {\n          throw new Error(\"`renderWord` must be synchronous function and not return a Promise.\");\n        }\n        return node;\n      })}\n    </>\n  );\n};\n\nexport default React.memo(DrawLine);\n","import * as React from 'react';\nimport DrawLine from './DrawLine';\n\nexport interface RenderWordProps {\n  key: number;\n  style: React.CSSProperties;\n}\n\ntype SpectrumProps = {\n  /**\n   * Width of the placeholder container\n   */\n  width?: number;\n  /**\n   * Possible colors of words, will be picked randomly\n   */\n  colors?: Array<string>;\n  /**\n   * Possible widths of words, will be picked randomly\n   */\n  wordWidths?: Array<number>;\n  /**\n   * Possible distance between words, will be picked randomly\n   */\n  wordDistances?: Array<number>;\n  /**\n   * Height of every word placeholder\n   */\n  wordHeight?: number;\n  /**\n   * Border radius of every word\n   */\n  wordRadius?: number;\n  /**\n   * Distance(margin) between the lines\n   */\n  lineDistance?: number;\n  /**\n   * Lines per paragraph\n   * if there are multiple paragraphs, all of them will have same number of lines\n   */\n  linesPerParagraph?: number;\n  /**\n   * Number of paragraphs in the placeholder\n   */\n  paragraphs?: number;\n  /**\n   * Distance(margin) between the paragraphs\n   */\n  paragraphDistance?: number;\n  /**\n   * Show less words in the last line for more natural feel\n   */\n  truncateLastLine?: boolean;\n  /**\n   * Render word with customizations\n   */\n  renderWord?: React.FC<RenderWordProps>;\n};\n\nconst Spectrum = ({\n  width = 500,\n  colors = ['#eee'],\n  wordWidths = [30, 60, 90, 120, 150],\n  wordDistances = [4, 8, 12],\n  wordHeight = 12,\n  wordRadius = 20,\n  linesPerParagraph = 8,\n  lineDistance = 12,\n  paragraphs = 1,\n  paragraphDistance = 24,\n  truncateLastLine = true,\n  renderWord = ({ key, style }: RenderWordProps): React.ReactElement => (\n    <span key={key} style={style} />\n  ),\n}: SpectrumProps): React.ReactElement => {\n  return (\n    <>\n      {new Array(paragraphs).fill(true).map((_, i) => {\n        const lines = new Array(linesPerParagraph).fill(true).map((__, j) => (\n          <div data-line={j} key={j}>\n            <DrawLine\n              width={width}\n              colors={colors}\n              wordWidths={wordWidths}\n              wordDistances={wordDistances}\n              wordHeight={wordHeight}\n              wordRadius={wordRadius}\n              lineDistance={lineDistance}\n              truncate={truncateLastLine ? j === linesPerParagraph - 1 : false}\n              renderWord={renderWord}\n            />\n          </div>\n        ));\n\n        return (\n          <div\n            data-paragraph={i}\n            key={i}\n            style={{\n              marginBottom: paragraphDistance,\n              fontSize: 0,\n            }}>\n            {lines}\n          </div>\n        );\n      })}\n    </>\n  );\n};\n\nexport default React.memo(Spectrum);\n"],"names":["_jsx","_Fragment","DrawLine"],"mappings":"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"}